%+================+
%| DOCUMENT SETUP |
%+================+

% Set document class
\documentclass[xcolor=dvipsnames,11pt,paper=a4paper]{report}

% Include packages
\include{format/packages}
\include{format/code}		% Code style setup

%+----------------+
%| Document style |
%+----------------+

% Set default font to sans-serif
\renewcommand*{\familydefault}{\sfdefault}
% Make monospaced font a little smaller to fit text size
\let\tt\ttfamily
\renewcommand*{\ttfamily}{\small\tt}

% No horizontal paragraph indentation
\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}

% Don't reset footnote counter with each chapter
\counterwithout{footnote}{chapter}

% Space before itemize/enumerate
\setlist[itemize]{topsep=-11pt}
\setlist[enumerate]{topsep=-11pt}

% Space after List of Figures etc.
\setlength\cftaftertoctitleskip{12pt}
\setlength\cftafterloftitleskip{12pt}
\setlength\cftafterlottitleskip{12pt}
\setlength{\cftbeforechapskip}{12pt}
\setlength{\cftbeforesecskip}{6pt}
\setlength{\cftbeforesubsecskip}{6pt}

% Set chapter style
\titleformat{\chapter}{\Huge\bfseries}{\thechapter. }{0pt}{\Huge\bfseries}
\titlespacing{\chapter}{0pt}{0pt}{20pt}
\titlespacing{\section}{0pt}{12pt}{0pt}
\titlespacing{\subsection}{0pt}{12pt}{0pt}
\titlespacing{\subsubsection}{0pt}{12pt}{0pt}

% Set author and title
\title{
	\Huge\textbf{Praxissemester bei isys vision GmbH \& Co. KG}\\\vspace{20pt}
	\huge{Bericht und Erfahrungen}
}
\author{
	\begin{tabular}{l l}
	Lorenz Bung &
	\href{mailto:lorenz.bung@htwg-konstanz.de}{\texttt{lorenz.bung@htwg-konstanz.de}}\\
	&HTWG Konstanz\\
	&Angewandte Informatik, 4. Semester
	\end{tabular}
}
\date{\today}

%+================+
%| DOCUMENT START |
%+================+
\begin{document}
\pagenumbering{gobble} % No page numbers for the introduction!

%+------------+
%| Title page |
%+------------+
\begin{titlepage}
\raggedright\includegraphics[width=0.5\textwidth]{media/isys.png}
{\let\newpage\relax\maketitle}
\end{titlepage}

%+----------+
%| Abstract |
%+----------+
\begin{abstract}
In diesem Bericht geht es um mein Praktikum bei isys vision GmbH \& Co. KG, welches
ich im Rahmen meines Studiums im Fach Angewandte Informatik im 4. Studiensemester
absolviert habe.

Ich werde beschreiben und erklären, welche Aufgaben mir weshalb gegeben wurden,
wie ich sie gelöst habe und welche Werkzeuge und Vorgehensweisen ich dabei verwendet
habe. Weiterhin werde ich die firmeninternen Abläufe, Ziele und Methoden nennen.
\end{abstract}

%+-------------------+
%| Table of contents |
%+-------------------+
\tableofcontents
\pagebreak

%+-------------------+
%| List of Listings, |
%| List of Figures,  |
%| List of Tables    |
%+-------------------+
\begingroup
\let\clearpage\relax
\lstlistoflistings
\listoffigures
\listoftables
\endgroup
\pagebreak

%+------------+
%| Einleitung |
%+------------+
\pagenumbering{arabic} % turn page numbering on now
\setcounter{chapter}{-1}
\chapter{Einleitung}
\label{ch:0}

Zu Beginn möchte ich kurz die Hintergründe meines Praktikums erläutern,
z.B. den Bewerbungsprozess, die Wahl der Firma und einige Informationen zu isys
vision.

Isys vision ist ein Softwarehersteller, der sich mit grafischen Lösungen auseinandersetzt.
Die Bildverarbeitung steht hierbei im Vordergrund und wird durch die von isys produzierte
Software durchgeführt. Die im selben Gebäude gelegene Tochterfirma Ensenso stellt
Hardwarekomponenten her, welche dann in Kombination mit der Software von isys vision
als Gesamtpaket an Endkunden, aber auch Großabnehmer verkauft wird. Dies umfasst
hauptsächlich Komponenten wie Kameras und Beleuchtungsbauteile sowie Verbindungskabel
usw.

Schon im Grundstudium war mir klar, dass ich für mein praktisches Studiensemester
Firmen im Bereich der Bildverarbeitung, -generierung oder aber im Webumfeld suchen
werde. Mit einem Praktikum in genannten Gebieten wollte ich einerseits meine Entscheidung
für die Vertiefungsrichtung der Medieninformatik im Hauptstudium bekräftigen, andererseits
war dies schon immer ein Bereich der Informatik, welcher mich besonders gereizt
hat. Aus diesen Gründen habe ich mich unter Anderem bei isys vision beworben und
schlussendlich ein halbes Jahr hier verbracht.




%+-----------+
%| Kapitel 1 |
%+-----------+
\chapter{Web-Oberfläche für das IVS}
\label{ch:ivs}

Das erste größere Projekt war die Entwicklung einer Web-Oberfläche für ein bereits
bestehendes, jedoch noch nicht vollständiges Bildverarbeitungssystem. Sowohl Webinterface
als auch Bildverarbeitung waren bereits vorhanden, jedoch nicht für den aktuellen
Anwendungszweck geeignet und somit war eine Überarbeitung unabdingbar.

Die Aufgabe des betreffenden Systems ist die Ausrichtung einzelner Keramikseiten,
welche dann in weiteren Schritten verarbeitet werden. Dabei geht es um die Produktion
von Lambdasonden, wie sie in der Abgasfilterung von Autos zum Einsatz kommen.

Diese Keramik-``sheets'' werden dabei mit hochpräziser Genauigkeit ausgestanzt,
weswegen sie vor dem Stanzen entsprechend ausgerichtet werden müssen. Eine physikalische
Ausrichtung ist dabei so gut wie unmöglich, da die gewünschte Genauigkeit dabei
nicht erreicht werden kann.

Das von isys entwickelte System erkennt nun mithilfe
zweier Kameras die Lage zweier Marken auf dem Sheet und somit die Lage auf dem verschieb-
und rotierbaren Tisch. Mithilfe der Bildverarbeitungssoftware wird nun eine Motorbewegung
errechnet, welche eine Ausrichtung des Werkstücks bewirkt. Anschließend kann das
Teil durch weitere Maschinen in seiner nun festgelegten Position weiterverarbeitet
werden.

Die Software besteht dabei nun aus drei verschiedenen Komponenten:
\begin{itemize}
	\item Dem \textit{ScbDrv}, welcher für die Ansteuerung der Motoren und Hardware
	verantwortlich ist.
	\item Dem \textit{IVS} (Isys Vision Server), welcher für die Auswertung der Kameradaten
	sowie die Bildverarbeitung und Errechnung der Endposition verantwortlich ist.
	\item Dem \textit{Webinterface}, welches dem Endkunden eine Möglichkeit zur Einsicht
	des aktuellen Status sowie zur Kontrolle über die Maschine gibt.
\end{itemize}

Während der ScbDrv nur geringfügig an die neue Maschinenkonfiguration angepasst
werden musste, war mein Betreuer mit der Anpassung des IVS an die neuen Marken (in
diesem Fall die Ecken der Keramiksheets) beschäftigt. Meine Aufgabe bestand aus
dem visuellen Redesign der Weboberfläche, dem Anpassen des Inhaltes (Entfernen überflüssiger
Elemente, Hinzufügen von neuen, wichtigen Dingen) sowie der Anpassung der Funktionalität
mithilfe von HTML, CSS und JavaScript.



\section{Einlesen in vorhandenen Code und Redesign}
\label{sec:ivs-einlesen}

Da das Interface auf der alten, bereits vorhandenen Version aufbauen sollte, war
das Einarbeiten in bereits vorhandenen Code notwendig. Um Änderungen vorzunehmen
war dabei ein großes Verständnis für diesen Code nötig, da es sich um komplexe und
vor allem abstrakte Abläufe handelte, die nicht leicht nachzuvollziehen waren.


\subsection{Flat-Design mithilfe von CSS}
\label{subsec:ivs-einlesen-css}

Da meine bisherigen Erfahrungen mit Javascript und jQuery mittelmäßig bis wenig
vorhanden waren, machte ich mir zunächst das grafische Redesign der Webseite zur
Aufgabe. Mit CSS hatte ich bereits gearbeitet, sodass ich mich verhältnismäßig schnell
in das vorhandene Stylesheet einarbeiten konnte und erste Änderungen vornahm.

Dazu gehörten beispielsweise das Entfernen von Schatten (\texttt{box-shadow}), was
Buttons und Menüs deutlich besser lesbar und sauberer macht, oder die Anpassung
von Farben (hellgrau wird ersetzt durch weiß etc). Auch wurde ein Hintergrundbild
von mir entfernt und durch eine durchgängige Farbe ersetzt, was zum gewünschten
``cleanen'' Erscheinungsbild beitrug.

Durch bereits wenige Änderungen im Stylesheet konnte ich hierbei recht große Erfolge
erzielen, was die Modernität der Seite angeht. Mit diesen Grundlagen mussten nun
Kleinigkeiten angepasst werden, wie beispielsweise zu große Listeneinträge in der
Menüleiste, fehlender Umrandung von Buttons oder Ähnlichem. Diese Anpassungen waren
minimal, jedoch war der Zeitaufwand dafür immens, da Regeln im CSS immer wieder
unterdrückt oder überschrieben wurden und erst das richtige Vorgehen bzw. die dafür
verantwortliche Regel ermittelt werden musste.

Schlussendlich waren die Anpassungen jedoch vorgenommen und ich konnte mich auf
Basis eines sauberen, nutzbaren und leserlichen Designs dem Verständnis und der
Modifikation des Javascript-Frameworks widmen.


\subsection{Javascript-Framework}
\label{subsec:ivs-einlesen-javascript}

In der bereits vorhandenen Version der Webseite wurde sämtliche Funktionalität durch
ein Javascript-Framework geregelt, welches unabhängig von Inhalt und Design steht.
Im Folgenden ging es nun darum, den hier geschriebenen Code durchzugehen, nachzuvollziehen,
zu verinnerlichen und zu verstehen. In etwa 1500 Zeilen waren Initialisierungsfunktionen,
Kommunikationsmodule und Eventhandler für Buttons etc. undokumentiert aufzufinden.

Aufgrund der trotz weniger Codezeilen doch sehr hohen Komplexität und vor allem
den fehlenden Kommentaren gestaltete es sich als sehr schwierig, sich einzuarbeiten.
Ein weiterer Nachteil war meine mangelnde Erfahrung mit Javascript; durch viel Recherche
und weiterführende Beispiele konnte ich mir jedoch einiges herleiten und somit verstehen.

Meine erste Änderung war hierbei das Ersetzen von javascript-basierten Zoom-Buttons
durch eine Leiste (in HTML ein \texttt{<input range>}-Element). Dies sah zum einen
deutlich besser aus und war einfacher zu bedienen, außerdem war somit der Inhalt
(in diesem Fall die Zoom-Leiste im HTML) besser von der Funktion getrennt.

\begin{figure}[H]
	\begin{minipage}{0.5\textwidth}
		\centering
		\includegraphics[width=\textwidth, height=\textwidth]{media/webinterface-alt.png}
		\caption{Interface vor dem Redesign}
		\label{fig:ivs-webinterface-alt}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
		\centering
		\includegraphics[width=\textwidth, height=\textwidth]{media/webinterface.png}
		\caption{Interface nach dem Redesign}
		\label{fig:ivs-webinterface}
	\end{minipage}
\end{figure}

Weitere Modifikationen am Framework umfassten vor allem die Vereinfachung und Lesbarkeit
des Codes. Die Hauptaufgabe in dieser Phase war das Verständnis, da dies die Grundlage
für weitere Arbeit am Javascript ist.



\section{Einschub: Filterfunktion für SVN-Repositories}
\label{sec:svn}

Da mein Betreuer, welcher mit mir gemeinsam für die Entwicklung des neuen IVS-Systems
verantwortlich war, krankheitsbedingt eineinhalb Wochen fehlte, war die weitere
Arbeit an der Weboberfläche für diese Zeit leider nicht möglich. In der Zwischenzeit
wurde mir dafür die Verbesserung der Oberfläche des Intranets aufgetragen.

Das Intranet enthält eine Liste von SVN-Repositories, die in Form eines Baumes dargestellt
werden. Die einzelnen Einträge sind dabei in verschiedenen Ebenen enthalten. Im
folgenden Codebeispiel (\texttt{HTML}) wird dies deutlich:

\begin{code}[language=html, caption={Beispielcode zu den SVN-Repositories im Intranet}, label={lst:svn-html-beispiel}]
<ul class="mktree" id="mktree1">
	<li id="1">Firma 1</li>
		<ul>
			<li id="1-1">Repository 1-1</li>
			<li id="1-2">Repository 1-2</li>
		</ul>
	</li>
	<li id="2">Repository 2</li>
	<li id="3">Firma 3
		<ul>
			<li id="3-1">Repository 3-1</li>
			<li id="3-2">Projekt 3-2
				<ul>
					<li id="3-2-1">Repository 3-2-1</li>
					<li id="3-2-2">Repository 3-2-2</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
\end{code}

Zur Darstellung des Baumes in aus- und einklappbarer Form wurde das schon vorhandene
Script \texttt{mktree} von
Matt Kruse\footnote{\url{http://www.mattkruse.com/javascript/mktree}} verwendet.

Meine Aufgabe bestand nun darin, eine Suchfunktion für Einträge in dieser Liste
zu implementieren. Dazu habe ich mithilfe von \texttt{JavaScript} und \texttt{jQuery}
gearbeitet und einige Funktionen geschrieben. Diese Funktionen basieren zudem auf
dem oben genannten Script (\texttt{mktree}) und bauen auf dessen Funktionalität
auf.

\begin{code}[language=javascript, caption={Filterfunktion für das Intranet}, label={lst:svn-filter}]
function filter() {
	var input = document.getElementById('searchInput');
	var filter = input.value.toLowerCase();
	var url = window.location.href.split("?")[0];
	document.getElementById("searchURL").href = url + "?filter=" + filter;
	//Search through all list items
	var li = $('li');
	for (var i = 0; i < li.length; i++) {
		//Get all parents of this node which have the filter.
		var parents =	$(li[i])
			.parents('li')
			.filter(function() {
			return this.textContent
				.trim()
				.split('    ')[0]
				.toLowerCase()
				.indexOf(filter) > -1;
		});
		//Select the correct String to search in.
		var str = li[i]
			.textContent
			.split(' (')[0] //Remove the ( browse / ...)
			.toLowerCase()
			.trim()
			.split("    ")[0]; //Bug fix
		if (str.indexOf(filter) > -1 || parents.length) {
			//Item or Parent contains filter
			li[i].style.display = ""; //Display normally
			$(li[i]).parents().each(function() {
				this.style.display = "";
			});
			if (li[i].id != "") {
				expandToItem('mktree1', li[i].id); //Expand tree
			}
			window.scrollTo(0, 0); //Fixes weird behaviour
		} else {
			li[i].style.display = "none"; //Hide item
		}
	}
}
\end{code}

Die oben geschriebene Funktion wird aufgerufen, sobald sich der Eingabewert des
\texttt{<input>}-Felds (siehe Zeile 8) ändert. Eine Änderung der Eingabe hat somit
zur Folge, dass die darunter stehende Liste von Repositories neu gefiltert wird
und nicht passende Einträge entsprechend versteckt werden.

Weiterhin wird die Funktionalität von \texttt{mktree} genutzt, um den Baum zu den
angezeigten Repositories automatisch aufzuklappen. Dies wird durch einen einfachen
Aufruf der richtigen Funktion erreicht.

Nach der Implementierung dieser Funktionalität habe ich noch eine weitere Verbesserung
an der Seite durchgeführt, wodurch sich der Cursor nicht im Textfeld befinden muss,
um zu suchen. Dies hat den Vorteil, dass direkt nach dem Laden der Webseite oder
auch nach dem manuellen Ein- bzw. Ausklappen des Baumes ohne weitere Mausbetätigung
gesucht werden kann.

\begin{code}[language=javascript, caption={Funktion für Suche auf Tastendruck}, label={lst:svn-onkeypress}]
document.onkeypress = function(event) {
	//Variables for search field and pressed key
	var input = document.getElementById('searchInput');
	var key = event.key;
	if (document.activeElement !== input && key.length === 1) {
		//Not focused => Put the pressed key in the search bar.
		input.value += key;
	}
	//Jump to the search field.
	input.focus();
}
\end{code}

Um dies zu erreichen, habe ich eine Funktion geschrieben, welche beim Tastendruck
aufgerufen wird. Die gedrückte Taste wird gespeichert und das Textfeld fokussiert.
Handelt es sich bei der Taste um einen Buchstaben (nicht etwa \texttt{backspace},
daher \texttt{key.length === 1}), so wird der Wert der Taste zusätzlich ins Textfeld
geschrieben, um einen doppelten Tastendruck zu vermeiden.

Eine letzte Optimierung der Seite erfolgte durch die Möglichkeit, eine Suchanfrage
in Form der URL zu speichern (ein sogenannter Permalink) und somit weiterleitbar
zu machen. Meine Vorgehensweise dafür war, den Filter mit dem entsprechenden Tag
\texttt{?filter=} an die URL anzuhängen. Beim Laden der Seite wird die URL dann
nach dem entsprechenden Tag durchsucht, und falls ein Tag gefunden wird, wird der
Inhalt des Suchfeldes gesetzt und die Filterfunktion aufgerufen.

Weiterhin wird auf der Webseite ein Hyperlink dargestellt, welcher immer zur aktuellen
Suchanfrage verlinkt. Durch Kopieren dieses Links kann die entsprechende Suche also
weitergeleitet werden. Erreicht wird dies durch das Aktualisieren der dabei hinterlegten
URL nach dem Aufruf von \texttt{filter()}.

\begin{code}[language=javascript, caption={Filterung beim Laden der Seite}, label={lst:svn-ready}]
document.ready = function() {
	//First, let's do some ugly bug fixing for mktree (-_-)
	setDefault("treeClass","mktree");
	setDefault("nodeClosedClass","liClosed");
	setDefault("nodeOpenClass","liOpen");
	setDefault("nodeBulletClass","liBullet");
	setDefault("nodeLinkClass","bullet");
	setDefault("preProcessTrees",true);

	var href = window.location.href;
	//Filter the URL to find the filter.
	var filter = undefined;
	try {
		filter =	href.split('?')[1] //after first "?"
							.split('filter=')[1] //after "filter="
							.split('&')[0]; //stop at next "&"
	} catch (e) {}
	if (filter != undefined) {
		//Filter found => search for it
		document.getElementById('searchInput').value = filter;
		document.getElementById('searchInput').onkeyup();
	}
	document.getElementById("searchURL").href = window.location.href;
}
\end{code}

Beim Laden der Webseite wird nun also der Filter in der URL ausgelesen und ins Textfeld
eingefügt.



\section{Dokumentation des Frameworks}
\label{sec:ivs-dokumentation}

Eine weitere wichtige Aufgabe war das Dokumentieren des bereits vorhandenen Codes.
Da der ursprüngliche Autor leider nicht mehr bei isys vision angestellt war und
ich mich nun schon länger damit auseinander gesetzt hatte, sollte nun eine umfassende
Dokumentation des Aufbaus erstellt werden.

Dies erleichtert einerseits die Arbeit am Framework selbst (Änderungen und Updates
beispielsweise) und bietet denjenigen, die es nur verwenden (z.B. für eine neue
Webseite mit demselben Framework) ein einfaches, gut verständliches Interface. Weiterhin
können komplexere Vorgänge wie die Datenübertragung anschaulich erklärt und mithilfe
von Diagrammen verdeutlicht werden.


\subsection{Codekommentierung mit JSDoc}
\label{subsec:ivs-dokumentation-jsdoc}

Im ersten Schritt arbeitete ich dabei nur am Quelltext selbst, den ich zuvor schon
in lesbare Form gebracht hatte. Durch zusätzliche Kommentare an wichtigen und irreführenden
Stellen konnte ich dabei eine erste Grundlage schaffen. Die größte Änderung war
die Einführung einer Codedokumentation im \texttt{JSDoc}-Format\footnote{\url{https://en.wikipedia.org/wiki/JSDoc}},
ähnlich zu den bei Java eingesetzten JavaDoc-Kommentaren. Die Vorteile davon liegen
auf der Hand: Jede Methode bzw. Funktion hat somit eine eigene Beschreibung, in
der Funktionsweise, Parameter, Rückgabewert usw. beschrieben werden.

Ein weiterer Vorteil von JSDoc ist die Möglichkeit, die Dokumentation automatisch
zu generieren. Dies ist mit dem JSDoc-Tool von \texttt{Node.js} möglich, was nach
der Installation einfach über den Befehl \texttt{jsdoc file.js} aufgerufen kann.
Somit wird ein gut strukturiertes Dokument (inklusive Referenzen) automatisch erstellt.


\subsection{Beschreibung der API}
\label{subsec:ivs-dokumentation-beschreibung}

Nachdem der Quellcode selbst dokumentiert war, konnte ich mich nun mit den internen
Abläufen des Frameworks beschäftigen und diese anhand von Grafiken anschaulich machen.
In diesem Fall ging es vor allem um die Daten- und Befehlsübertragung vom IVS zum
Webinterface und umgekehrt.

Die Übertragung der Daten erfolgt hierbei über eine \texttt{XMLHttpRequest}, bzw.
(bei älteren Browsern) über ein \texttt{ActiveXObject}. Die Befehlscodes sind dabei
im HTML-Code der betreffenden Buttons gespeichert:

\begin{code}[language=html, caption={Ins HTML eingebettete Befehle für das IVS}, label={lst:ivs-html-befehle}]
<input type="text" size="6" maxlength="6" name="lms/SheetF.MinQuality">
<button name="lms/Cmd" value="10">Ausrichtung</button>
<button name="lms/Cmd" value="20">
	<ul>
		<li>LmsScb/Mot.RefOk</li>
		<li>Referenzfahrt</li>
	</ul>
</button>
\end{code}

In Zeile 1 wird beispielsweise das Register \texttt{lms/SheetF.MinQuality} geschrieben
und auf einen sechsstelligen Wert gesetzt, der vom Nutzer eingegeben wird.\\
In Zeile 2 befindet sich ein einfacher Befehlsbutton, der den Wert \texttt{10} ins
Register \texttt{lms/Cmd} schreibt (beim IVS ist dies der Code für eine Ausrichtung).\\
In den Zeilen 3 - 8 findet sich nun ein Knopf mit Status, der
\begin{itemize}
	\item den Wert \texttt{20} ins Register \texttt{lms/Cmd} schreibt und somit eine
	Referenzfahrt auslöst
	\item innerhalb der unsortierten Liste (Zeile 5) den Wert \texttt{LmsScb/Mot.RefOk}
	liest (Status der Referenzfahrt).
\end{itemize}
Die Liste (\texttt{<ul>}) dient dabei ausschließlich der Darstellung und hat keine
Auswirkung auf die Funktion; die Listenelemente werden innerhalb des Buttons entsprechend
formatiert. Weiterhin wird je nachdem, was im gelesenen Register \texttt{LmsScb/Mot.RefOk}
steht, ein entsprechendes Label gesetzt (grün falls Referenzfahrt OK, rot falls
nicht).

Im Javascript-Framework wird nun ein Event-Listener für alle Buttons und Eingabefelder
erstellt, der dann die entsprechenden Befehle erkennt. Diese werden in Form einer
URL in einer Liste gespeichert, welche dann mithilfe der bereits genannten \texttt{XMLHttpRequest}
bzw. des \texttt{ActiveXObject}s ans IVS gesendet werden. Die Antwort des IVS wird
dann entsprechend weiterverarbeitet und beispielsweise in Form eines Kamerabildes
direkt ausgegeben.




%+-----------+
%| Kapitel 2 |
%+-----------+
\chapter{Integration von Jira und Confluence}
\label{ch:jira}

Das nächste größere Projekt war die Integration der Atlassian-Produkte \textit{Jira}
und \textit{Confluence} in den Firmenalltag. Diese beiden Programme sind für das
Production Management gedacht und haben das Ziel, einen durchgängigen, geplanten
und leicht nachvollziehbaren Arbeitsfluss zu erreichen.

Confluence ist dabei ein einfaches System, dessen Ziel die einfache Weitergabe von
Informationen ist. Es dient der Erstellung von Dokumenten, welche externe Daten
wie beispielsweise Microsoft-Office-Dokumente oder YouTube-Videos sowie Bilder usw.
enthalten können und vereinfacht die Zusammenarbeit mehrerer Personen an einem Dokument.

Jira arbeitet im Zusammenspiel mit Confluence und ist ursprünglich für die Softwareentwicklung
gedacht. Entwicklungsvorgehensweisen wie \textit{Scrum} o.Ä. können hier ohne Umwege
umgesetzt werden und Jira bietet Funktionalitäten wie Sprints oder Burndown-Charts
an, um den Arbeitsfluss zu sichern.

Die Verwendung von Jira und Confluence sollte das davor eingesetzte (und veraltete)
Tool \textit{easyPM} ersetzen, welches für die Planung von Aufgaben, Abläufen und
Verwaltung von Zeitspalten eingesetzt wurde. Informationen wie E-Mails, Anrufprotokolle
oder sonstige Daten waren hier jedoch dezentral, bzw. konnten nicht direkt in easyPM
gespeichert werden. Durch das Zusammenspiel der beiden neuen Systeme sollte dieses
Problem behoben und die Speicherung der Daten konsistent werden.



\section{Einrichtung der Datenbank}
\label{sec:jira-einrichtung-datenbank}

Jira und Confluence sind beides Tools, die über einen Server laufen und dann über
den Webbrowser der Endgeräte aufgerufen werden können. Dies sichert zum einen die
Zentralität der Datenspeicherung und -verarbeitung und entlastet andererseits die
Nutzergeräte stark. Weiterhin ist die Nutzung eines firmeninternen Servers (welcher
außerdem für andere Zwecke wie das Intranet schon vorhanden war) sinnvoll, da somit
die Sicherheit der gespeicherten Daten gewährleistet wird.

Für den Aufbau des Webservers wird dabei sowohl von Jira als auch von Confluence
eine Datenbank verwendet. Das kann sowohl eine \textit{MySQL}-, \textit{Oracle}-
oder \textit{Microsoft-SQL}-Datenbank sein, oder aber auch die Open-Source-Alternative
\textit{PostgreSQL}. Wegen der eher schlechten Unterstützung von MySQL habe ich
schlussendlich eine PostgreSQL-Datenbank eingesetzt.

PostgreSQL ist ein freies und quelloffenes Datenbankmanagementsystem. Es wird von
Betriebssystemen wie Windows, Linux und anderen UNIX-ähnlichen Systemen unterstützt
und wird bei den meisten Linux-Distributionen bereits mitgeliefert.

Um den Linux-Server von isys zu simulieren und die Datenbank entsprechend einzurichten,
habe ich eine virtuelle Maschine mit einer Ubuntu-Installation verwendet. Nach der
Einrichtung des Systems konnte ich mit der Konfiguration des Datenbankservers beginnen.
Nach einiger Verwirrung und etwas Recherche stellte sich heraus, dass für das Erstellen
einer Tabelle in PostgreSQL ein Linux-Nutzername angegeben werden muss. Dies war
praktisch, da die Jira- und Confluence-Systemdienste sowieso einen eigenen Account
erstellten, den ich somit direkt mitverwenden konnte. Ich hatte nun also drei Zugänge:

\begin{itemize}
	\item \texttt{ubuntu}, Super-User-Account und Hauptaccount des Rechners,
	\item \texttt{confluence}, für die Datenbank und den Systemdienst des Confluence-Servers,
	\item \texttt{jira}, für die Datenbank und den Systemdienst des Jira-Servers.
\end{itemize}

Mit einigen einfachen SQL-Befehlen waren die notwendigen Datenbanken dann auch schnell
erstellt:

\begin{code}[language=SQL, caption={SQL-Befehle zur Erstellung der Datenbanken}, label={lst:jira-database}]
CREATE DATABASE confluencedb WITH ENCODING 'UNICODE';
GRANT ALL PRIVILEGES ON DATABASE confluencedb TO confluence;

CREATE DATABASE jiradb WITH ENCODING 'UNICODE';
GRANT ALL PRIVILEGES ON DATABASE jiradb TO jira;
\end{code}

Zur Anbindung an Jira bzw. Confluence musste nun nur noch bei der Einrichtung jeweils
die entsprechenden Datenbankdaten angegeben werden. Da hier der Jira- bzw. Confluence-Server
und die Datenbank auf dem selben Rechner laufen, ist der Host beispielsweise \texttt{127.0.0.1}
bzw. \texttt{localhost}.

Die Installation von Jira und Confluence erfolgte dann einfach über die Ausführung
eines Shell-Skriptes und die Eingabe einer Lizenz. Somit war die Einrichtung der
Systeme vollständig und ich konnte einige Einstellungen vornehmen, z.B. Anpassungen
im Design der Seiten, sodass die Oberfläche den Farben der Firma entsprach
(\textcolor[HTML]{006833}{Grün [\texttt{\#006833}]} und \textcolor[HTML]{9B2536}{Rot [\texttt{\#9B2536}]}).



\section{Einrichtung des Intranetservers}
\label{sec:jira-server}

Nun, da Jira und Confluence online und konfiguriert waren, setzte ih mich mit der
Einrichtung eines Servers auseinander, welcher im Intranet betrieben werden und
die beiden Webtools hosten sollte.

Im ersten Schritt machte ich den dafür zur Verfügung gestellten Rechner nutzbar,
indem ich eine frische Linux-Installation vornahm. Auf dieser Basis konnte ich nun
mit \texttt{VirtualBox}\footnote{\url{https://wiki.ubuntuusers.de/VirtualBox/Installation/\#VirtualBox-OSE-Open-Source-Edition}}
eine virtuelle Maschine einrichten; auch darauf lief ein Linux-Betriebssystem. Die
Nutzung einer virtuellen Maschine hatte hierbei mehrere Vorteile:
\begin{enumerate}
	\item \textbf{Flexibilität}:
	Durch das Speichern in einem \textbf{Disk Image} ist der Ort des Servers
	sehr leicht austauschbar. Durch Verschieben des Images sind sämtliche Daten des
	Servers übernommen, was die Wartung stark vereinfacht.
	\item \textbf{Sicherheit}:
	Da die Daten in einem einzigen Image liegen, welches auf der Festplatte des
	Wirtrechners gespeichert wird, ist die Datensicherung bzw. Erstellung von Backups
	besonders komfortabel. Mithilfe eines RAID-Systems wird in diesem Fall die Datensicherheit
	gewährleistet und Backups erstellt.
	\item \textbf{Vielseitigkeit}:
	Der Server läuft in einer virtuellen Maschine, welche auf die Ressourcen
	des Wirtrechners zugreift. Durch das Einrichten einer weiteren virtuellen Maschine
	kann dessen Rechenleistung und Speicherkapazität optimal ausgenutzt werden und
	die Maschine somit auch für andere Zwecke verwendet werden.
\end{enumerate}

Nach erneuter Einrichtung der in Kapitel \ref{sec:jira-einrichtung-datenbank} beschriebenen
Datenbank und der Anbindung an Jira/Confluence musste ich mich nun noch mit der
Netzwerkverbindung auseinandersetzen. Die zugeordnete IP-Adresse sollte dabei
\texttt{10.0.0.14} sein; Jira und Confluence jeweils unter den Standardports
\texttt{8080} bzw. \texttt{8090} erreichbar sein.

Als Erstes musste die virtuelle Maschine über eine Netzwerkbrücke auf das lokale
Netzwerk zugreifen können. Dies war schnell eingestellt; eine einfache Änderung
im VirtualBox-Interface genügte dafür. Mithilfe der Netzwerkbrücke wird hier das
lokale Netzwerk (isys vision Intranet) mit dem von der virtuellen Maschine erstellten
Netzwerk verbunden, sodass diese die gehosteten Services auf die Webports anlegen
kann.

Im nächsten Schritt braucht die virtuelle Maschine eine feste (statische) IP-Adresse.
In diesem Fall sollte dies die \texttt{10.0.0.14} sein. Um diese zuzuweisen, kann
unter Linux die Datei \texttt{/etc/network/interfaces} bearbeitet werden:
\begin{code}[language=bash, caption={Änderungen in \texttt{/etc/network/interfaces}}]
auto enp0s3 #Name der Netzwerkbrücke
iface enp0s3 inet static #IP auf Statisch ändern
#Setzen von Verbindungsinformationen
netmask 255.255.0.0
gateway 10.0.0.10
network 10.0.0.0
broadcast 10.0.0.255
dns-nameservers 10.0.0.10
\end{code}
Mithilfe dieser Änderungen wird dem Rechner eine statische Adresse zugewiesen. Dies
ist hier notwendig, da der Rechner sonst bei jedem Start vom Router eine neue, variable
Adresse zugewiesen bekommt. Damit der Server also immer mit der selben Adresse erreichbar
ist, muss die IP fest sein. Später lässt sich auch eine DNS zuweisen, beispielsweise
\texttt{intranet.isys-vision.de/jira}.




\chapter{Web-Tools für das Mikado-Projekt}

Nach meiner Arbeit am IVS, Jira und Confluence wurde ich nun Teil eines anderen
Projekts namens Mikado\footnote{\url{http://www.mikado-robotics.de}}. Mikado ist ein Robotikprojekt,
bei dem es hauptsächlich um das sogenannte ``Bin Picking'' geht. Dabei wird ein
Roboter dazu eingesetzt, zufällig in einer Kiste liegende Teile mithilfe einer 3D-Kamera
zu erkennen, zu greifen und in eine andere Position zu bringen. Die Herausforderung
liegt hierbei beim Leeren der Kiste, d.h. alle sich darin befindlichen Teile gleichgültig
ihrer Position greifen zu können.



\section{Demoablauf für Messen}

Zum Kennenlernen der Programmschnittstelle und des Roboters sollte ich zunächst
mit dem von isys geschriebenen Programm einen Demoablauf aufbauen, welcher für
Messen oder ähnliche Anwendungsfälle verwendet werden sollte. Im Programm lassen
sich dafür Abläufe graphisch regeln, beispielsweise eine Bewegung, das Greifen
eines Teils oder die Bildaufnahme mit der 3D-Kamera. Diese noch nicht veröffentlichte
Software konnte somit außerdem von mir getestet und Verbesserungsvorschläge geäußert
werden.

Zur Erkennung der Teile wird mithilfe der Kameras ein 3D-Bild aufgenommen, welches
anschließend von der Recheneinheit analysiert und zu einer Punktwolke transformiert
wird. Diese Punktwolke wird nun mit dem eintrainierten CAD-Modell abgeglichen und
somit mögliche Kandidaten anhand ihrer Übereinstimmung identifiziert. Die dabei
gewählte Mindestübereinstimmung lässt sich dabei einstellen, was je nach Wert
Vor- bzw. Nachteile mit sich bringt:

\begin{table}[H]
	\begin{tabular}{| l || l |}
	\hline
	\textbf{Höhere Mindestqualität} & \textbf{ Niedrigere Mindestqualität}\\
	\hline\hline
	Erkannte Teile können mit höherer Sicherheit & Erkannte Teile können sich in nahezu un-\\
	richtig und sicher gegriffen werden & greifbarem Winkel befinden und daher nicht\\
	& sicher gegriffen werden\\
	\hline
	Weniger Teile werden erkannt, daher höhere & Viele Teile werden erkannt, die Wahrschein-\\
	Chance, die Kiste nicht leer zu bekommen & lichkeit ist daher größer, alle verbleibenden\\
	& Teile zu identifizieren\\
	\hline
	\end{tabular}
	\caption{Vor- bzw. Nachteile einer höheren vs. niedrigeren Mindestqualität}
	\label{mikado-demo-mindestqualität}
\end{table}

Die Bewegungen des Robotors lassen sich entweder über die Winkel der einzelnen Gelenke
(beim von isys verwendeten Roboter von Mitsubishi Electrics sind es 6 Gelenke) oder
das Format \texttt{xyz rpy} (\texttt{xyz} ist hierbei die Position im Raum (3 Koordinaten),
\texttt{rpy} (roll, pitch, yaw) die Drehung des Greifers) angeben. Sämtliche Bewegungen
und Rotationen sind dabei kollisionsgeprüft, d.h. sobald das System eine mögliche
Kollision erkennt, wird die Bewegung nicht ausgeführt. In diesem Fall kann eine
alternative Aktion durch einen Sprung im Programmablauf durchgeführt werden.

Über einzelne Sektionen und Sprünge lässt sich nun ein strukturiertes Programm erstellen,
was sowohl einfache Funktionen (wie in diesem Fall eine Demonstration der Funktionalität)
oder auch komplexe Abläufe wie den Zusammenbau eines Schneckengewindes übernehmen
kann. Der Programmablauf kann dabei mit den Funktionen \texttt{start}, \texttt{pause},
\texttt{step} und \texttt{reset} gesteuert werden, was in folgenden Aufgaben noch
wichtig wird.

Mein Demonstrationsprogramm war hierbei die Abwandlung einer älteren Demo. Der Roboter
nimmt dabei Zahnräder aus einer Kiste, testet mithilfe einer Lichtschranke, ob er
das Teil tatsächlich gegriffen hat, und legt dieses schlussendlich so ab, dass der
Schriftzug ``isys'' entsteht. Ist dies geschehen, nimmt er nacheinander die abgelegten
Teile wieder auf und legt sie zurück in die Kiste.

Der Zweck der Demonstration ist einerseits das Heranführen an den Roboter an sich
(z.B. die Arbeitsweise der Maschine oder die graphische Programmierung) sowie die
Fähigkeit, wirklich sämtliche Teile aus der Kiste nehmen zu können, zu demonstrieren.
Erreichen lässt sich dies einfach dadurch, dass zu Beginn nur so viele Zahnräder
in die Kiste gelegt werden, wie am Ende auch für den Schriftzug benötigt werden.



\section{Web-Remote für die Mikado-Software}

Für die Demonstration bei Messen oder bei ähnlichen Veranstaltungen sollte nun von
mir ein Webinterface erstellt werden, was als Fernzugriff für die Mikadosoftware
verwendet werden kann. Der Sinn dahinter ist, dass der Programmablauf nicht mehr
ausschließlich mithilfe von Bildschirm und Tastatur gesteuert, sondern beispielsweise
über ein Smartphone modern und komfortabel bedient werden soll. Dies ist insbesondere
nützlich, da aus Sicherheitsgründen bei Vorführungen eine Glaswand vor dem Roboteraufbau
ist, was Eingriffe in den Ablauf stark erschwert.


\subsection{Design der neuen Webseite}

Nachdem ich im \ref{ch:ivs}. Projekt bereits mit Javascript, CSS und HTML in Berührung
gekommen war, konnte ich nun eine völlig neue Webseite basierend auf meinen erlangten
Kenntnissen selbstständig und von Grund auf aufbauen. Dazu kümmerte ich mich zuerst
um Inhalt und Design der neuen Seite und fügte anschließend die Funktionalität durch
Javascript und jQuery hinzu.

\subsubsection{Struktur mit HTML}

Zunächst gliederte ich die neue Webseite mithilfe der zugehörigen HTML-Tags in sinnvolle
Abschnitte. Mit \texttt{<nav>}, \texttt{<main>} und \texttt{<footer>} sowie geschachtelten
\texttt{<div>}-Tags konnte ich eine sinnvolle Struktur in den Inhalt der Seite bringen.

Im \texttt{<nav>}-Teil der Seite wird die Navigationsleiste definiert; in meinem
Fall umfasste sie die Listenpunkte \textbf{Logs}, \textbf{Kontrolle} und \textbf{Über}
sowie ein \textbf{Hamburger-Menü-Icon}\footnote{\url{https://de.wikipedia.org/wiki/Hamburger-Men\%C3\%BC-Icon}},
welches zum Ein- und Ausklappen des Menüs notwendig war. Im \texttt{<main>}-Teil
des HTML-Dokuments wird sämtlicher Inhalt der Seite definiert, also in meinem Fall
das Logfenster, die Kontroll- und die Informationsseite. Diese einzelnen Abschnitte
sind jeweils wieder in einzelne \texttt{<div>}s geteilt, sodass Struktur und Design
gewährleistet werden können. Schlussendlich befinden sich im \texttt{<footer>}-Element
einige Informationen über das Produkt, wie z.B. Copyright, Webseite oder Kontakt.

\begin{code}[language=html, caption={Struktur der Kontrollseite}]
<div id="control" class="content">
	<div class="control-window">
		<div class="control-element">
			<button onclick="start()">
				<img src="media/start.svg" alt="Start">
			</button>
		</div>
		<div class="control-element">
			<button onclick="step()">
				<img src="media/step.svg" alt="Step">
			</button>
		</div>
		<div class="control-element">
			<button onclick="pause()">
				<img src="media/pause.svg" alt="Pause">
			</button>
		</div>
		<div class="control-element">
			<button onclick="reset()">
				<img src="media/reset.svg" alt="Reset">
			</button>
		</div>
	</div>
</div>
\end{code}

Wie man sieht, bestehen die Kontrollbuttons aus einem Funktionsaufruf (den ich erst
später implementiert habe) und einer SVG-Grafik\footnote{\url{https://de.wikipedia.org/wiki/Scalable\_Vector\_Graphics}}.

\subsubsection{Erstellen von SVG-Grafiken}

SVG-Grafiken haben den großen Vorteil, dass sie vom Browser gerendert werden. Dadurch
ist einerseits keine große Bilddatei notwendig, was (insbesondere auf mobilen Endgeräten)
zu sehr schnellen Ladezeiten führt, und andererseits auch nicht das Problem zu geringer
Auflösungen mit sich bringt, wodurch die Grafik immer gestochen scharf ist. Da jedoch
keine entsprechenden Grafiken vorhanden waren, musste ich diese selbst erstellen.
Auch für das Navigationsmenü habe ich SVG-Dateien entworfen.

Der Inhalt einer SVG-Grafik ist der Syntax von HTML bzw. XML sehr ähnlich. Zunächst
wird mit dem Tag \texttt{<svg>} gekennzeichnet, dass es sich um eine SVG-Grafik
handelt. Innerhalb dieses Tags können nun Bildelemente hinzugefügt werden:

\begin{code}[language=svg, caption={Bildelemente in einer SVG-Grafik}]
<svg width="54" height="54" viewBox="0 0 54 54" xmlns="http://www.w3.org/2000/svg" xmlns:xlink= "http://www.w3.org/1999/xlink">
	<circle
		cx="27" cy="27" r="25"
		stroke="black" stroke-width="4" fill="none"
	/>
	<line
		x1="18" y1="13"
		x2="18" y2="41"
		stroke="black" stroke-width="8" stroke-linecap="butt"
	/>
	<line
		x1="36" y1="13"
		x2="36" y2="41"
		stroke="black" stroke-width="8" stroke-linecap="butt"
	/>
</svg>
\end{code}

Hier wird beispielsweise zunächst ein umschließender Kreis definiert (ll. 2 - 5),
welcher den Mittelpunkt $P(27|27)$ und den Radius $r = 25$ hat. Die Linienfarbe
soll Schwarz sein, die Linienbreite 4 Pixel und der Kreis soll nicht gefüllt sein.
Anschließend werden zwei Linien gezeichnet, jeweils mit der Farbe Schwarz, der Breite
8px und einem geraden Linienende. Linie 1 geht in diesem Fall von $P(18|13)$ nach
$Q(18|41)$.

\subsubsection{Stilregeln durch CSS}

Im nächsten Schritt ging es um das Design mithilfe von CSS. Die vorhergehend definierten
Inhalte konnte ich nun schöner Darstellen, indem ich Stilregeln für bestimmte Elemente
und Klassen vornahm. Dazu gehörten unter Anderem die Schriftart, Farbschema für
Menüleiste und Links oder auch Positionierung von Abschnitten und Festlegen von
Abständen.

Sehr wichtig war hierbei die Orientierung an relativen Werten wie der Bildschirmweite
(\texttt{viewport width}). Da es sich hierbei um ein für Mobilgeräte optimiertes
Webinterface handelt, spielt Skalierbarkeit auf unterschiedliche Größen eine große
Rolle. Umsetzen lässt sich dies beispielsweise durch ein sogenanntes \textbf{Responsive
Design}\footnote{\url{https://de.wikipedia.org/wiki/Responsive_Webdesign}}, bei dem
die Webseite der Bildschirmgröße entsprechend reagiert. Dies sichert auch eine gute
und intuitive Darstellung beim Wechsel vom Portrait- in den Landschaftsmodus (z.B.
bei Tablet PCs).

In der Umsetzung erfolgt dies durch die Vermeidung von Pixelwerten (z.B. \texttt{width: 12pt;})
und die Ersetzung ebenjener durch relative Werte (wie beispielsweise \texttt{width: 1em;}).
Somit wird die Größe von Elementen immer von der Bildschirm- oder Schriftgröße abhängig
gemacht und passt sich dementsprechend an.

Weiterhin werden mithilfe eines \texttt{@media}-Tags im CSS für besonders kleine oder
besonders große Geräte andere Regeln angegeben, welche zumeist die davor definierten
Regeln überschreiben. Dies verhindert eine unproportionale Darstellung, wie z.B.
extrem verkleinerte Bilder, unleserliche Schrift oder aber im Gegenteil riesige
Buttons oder Überschriften.

Mit CSS konnte ich weiterhin einige Animationen erreichen, zum Beispiel ein Popup
beim Klick auf die Kontrollbuttons. Dies lässt sich über das CSS-Attribut \texttt{transition}
erreichen. Mit \texttt{transition: width .1s linear;} bekommt man beispielsweise
einen 100 ms lang andauernden Übergang betreffend der Breite. In meinem Fall hatte
ich für \texttt{button:hover} einen anderen Stil festgelegt als für einen normalen
Button, und zwar ein größeres Icon und weniger Durchsichtigkeit. Beim Übergang zu
\texttt{button:active} wird das Icon jedoch wieder klein, was einen ``Klick''-Effekt
zur Folge hat.




%+==============+
%| DOCUMENT END |
%+==============+
\end{document}